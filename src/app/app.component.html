<div class="container">
  <div class="header">
    <h1>Дополнительные задания к уроку №6 (Директивы)</h1>
  </div>
  <div class="dops">
    <div class="dop1 dop">
      <div class="exercise">
        <h2>Задание №1</h2>
        <p>Необходимо создать атрибутную директиву в Angular, которая динамически изменяет цвет фона элемента в
          зависимости от текущего времени суток.</p>
        Требования:
        <div class="double-ul">
          <ul><b>Определение времени суток:</b>
            <li>Утро (06:00-11:59)</li>
            <li>День (12:00-17:59)</li>
            <li>Вечер (18:00-23:59)</li>
            <li>Ночь (00:00-05:59)</li>
          </ul>
          <ul><b>Цвета для каждого периода времени суток:</b>
            <li>Утро: светло-жёлтый (по умолчанию)</li>
            <li>День: голубой (по умолчанию)</li>
            <li>Вечер: оранжевый (по умолчанию)</li>
            <li>Ночь: тёмно-синий (по умолчанию)</li>
          </ul>
        </div>
        <ul><b>Директива должна:</b>
          <li>Автоматически определять текущее время суток и применять соответствующий цвет фона.</li>
          <li>Поддерживать возможность задания пользовательских цветов для каждого периода времени суток через
            декоратор &#64;Input.
          </li>
          <li>Поддерживать возможность задания пользовательского времени через декоратор &#64;Input, для расчета времени
            суток.
          </li>
          <li>Быть универсальной и применимой к любым элементам DOM, таким как div, p, span и т.д.</li>
        </ul>
        <ul><b>Результат выполнения задания:</b>
          <li>При применении директивы к элементам на странице, их фон будет изменяться в зависимости от текущего
            времени
            суток или пользовательского времени, если оно задано.
          </li>
          <li>На странице должен быть виден измененный фон элементов, к которым применена директива.</li>
        </ul>
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop1></app-dop1>
      </div>
    </div>
    <div class="dop2 dop">
      <div class="exercise">
        <h2>Задание №2</h2>
        <p>
          Разработайте директиву appAutoExpandTextarea, предназначенную для элементов &lt;textarea&gt;, которая
          динамически адаптирует высоту элемента в зависимости от объёма введенного текста.
        </p>
        <b>Требования:</b>
        <ul><b>Динамическая адаптация высоты:</b>
          <li>Директива должна автоматически увеличивать высоту текстового поля при увеличении количества текста.</li>
          <li>Директива должна автоматически уменьшать высоту текстового поля при удалении текста, но не должна
            уменьшаться
            ниже начальной высоты поля.
          </li>
        </ul>

        <ul><b>Максимальная высота:</b>
          <li>Должна быть предусмотрена возможность задания максимальной высоты текстового поля через параметр.</li>
          <li>Если высота текстового поля достигает максимального значения, должна активироваться стандартная прокрутка,
            чтобы пользователь мог прокручивать содержимое.
          </li>
        </ul>

        <ul><b>Универсальность:</b>
          <li>Директива должна быть применимой к любым элементам &lt;textarea&gt; в документе.</li>
        </ul>

        <ul><b>Инициализация:</b>
          <li>При инициализации компонента высота текстового поля должна быть настроена исходя из объема уже введенного
            текста.
          </li>
        </ul>

        <ul><b>Описание результата:</b>
          <li>Результатом выполнения задания будет динамически изменяющаяся высота текстового поля &lt;textarea&gt;,
            которая
            адаптируется к количеству введенного текста, избегая появления скроллбара, за исключением случаев, когда
            высота
            текста превышает максимальную заданную высоту.
          </li>
        </ul>
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop2></app-dop2>
      </div>
    </div>
    <div class="dop3 dop">
      <div class="exercise">
        <h2>Задание №3</h2>
        <p>
          Разработать директиву TrackUserTimeDirective, которая будет отслеживать и записывать время, проведенное
          пользователем на веб-странице. Собранные данные должны быть сохранены в localStorage. Через &#64;Input
          директива
          должна принимать настройки параметров, таких как интервалы сохранения.</p>
        <ul class="ohne-markers">Требования:
          <li>
            <ul>Отслеживание времени:
              <li>Директива должна отслеживать время, проведенное пользователем на странице, и обновлять это значение
                каждую
                секунду. При обновлении страницы время должно отсчитываться от того, что было уже сохранено в хранилище,
                а не с
                нуля.
              </li>
            </ul>
          </li>
          <li>
            <ul>Сохранение в localStorage:
              <li>Собранные данные о времени должны сохраняться в localStorage браузера.</li>
            </ul>
          </li>
          <li>
            <ul>Настройки параметров:
              <li>Директива должна принимать настройки параметров через &#64;Input, такие как интервалы сохранения
                данных.
              </li>
            </ul>
          </li>
          <li>
            <ul>Результат выполнения:
              <li>Директива TrackUserTimeDirective отслеживает время, проведенное пользователем на странице, обновляя
                его каждую
                секунду и сохраняет это время в localStorage. Интервал сохранения настраивается через входной параметр
                saveInterval, что позволяет управлять частотой сохранения данных в хранилище без перезагрузки страницы.
              </li>
            </ul>
          </li>
        </ul>
        <p>
          Важно! Не путать интервал сохранения (передаётся через входные параметры, по умолчанию равен 5 секунд) и время
          обновления данных (это константа, равна 1 секунду)</p>
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop3></app-dop3>
      </div>
    </div>
    <div class="dop4 dop">
      <div class="exercise">
        <h2>Задание №4</h2>
        <p>
          Разработайте атрибутную директиву appToggleViewMode для компонента, который отображает список пользователей и
          их
          аватары.</p>

        Требования:
        <ul>Функциональность:
          <li>Директива должна позволять переключаться между двумя режимами отображения: линейным списком (list) и
            сеткой
            (grid).
          </li>
          <li>Директива будет применена к контейнеру, который содержит элементы списка пользователей.</li>
          <li>В зависимости от выбранного режима, структура отображения элементов внутри этого контейнера должна
            изменяться.
          </li>
          <li>Директива должна изменять классы CSS контейнера в соответствии с текущим режимом отображения. Классы CSS
            должны быть настроены так, чтобы они соответствовали принятому значению и изменяли структуру отображения
            элементов.
          </li>
        </ul>

        <ul>Режимы отображения:
          <li>В режиме list все элементы должны выстраиваться в один вертикальный ряд.</li>
          <li>В режиме grid элементы должны располагаться матрицей.</li>
        </ul>
        <ul>Входные параметры:
          <li>Директива должна принимать значение, указывающее текущий режим отображения (либо 'list', либо 'grid'),
            через &#64;Input.
          </li>
        </ul>

        Результат выполнения: <br>
        - Компонент должен отображать список пользователей с аватарами в зависимости от выбранного режима (list/grid).
        Например, в режиме 'list' все элементы выстраиваются в один вертикальный ряд, а в режиме 'grid' элементы
        располагаются в виде сетки. Пользовательский интерфейс должен позволять переключаться между режимами отображения
        списка и сетки, изменяя структуру отображения элементов.
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop4></app-dop4>
      </div>
    </div>
    <div class="dop5 dop">
      <div class="exercise">
        <h2>Задание №5</h2>
        <p>
          Разработайте атрибутную директиву appAutoSelectSingleOption для элементов &lt;select> в вашем веб-приложении.
          Эта
          директива предназначена для автоматического выбора единственного доступного значения из выпадающего списка,
          если в списке присутствует только один элемент
          &lt;option> для выбора.</p>

        Требования:
        <ul>Функциональность:
          <li>Директива должна автоматически выбрать единственный доступный &lt;option> элемент в элементе &lt;select>,
            если это единственный элемент в списке.
          </li>
          <li>Директива будет применена непосредственно к элементу &lt;select>, содержащему элементы &lt;option></li>
          <li>Это должно упрощать взаимодействие пользователя с формой, автоматически выбирая единственный доступный
            вариант, и тем самым ускорять процесс заполнения формы.
          </li>
          <li>Директива не должна вмешиваться, если в списке &lt;select> больше одного элемента &lt;option> доступно для
            выбора.
          </li>
        </ul>

        Результат выполнения: <br>
        Когда пользователь сталкивается с элементом &lt;select>, к которому применена директива
        appAutoSelectSingleOption,
        и если этот список содержит только один
        &lt;option> элемент, этот элемент автоматически выбирается. Это упрощает и ускоряет заполнение форм, минимизируя
        количество действий пользователя для выбора элементов в выпадающих списках, когда доступен только один вариант
        выбора. Если список содержит несколько
        &lt;option> элементов, значение select должно быть пустым
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop5></app-dop5>
      </div>
    </div>
    <div class="dop6 dop">
      <div class="exercise">
        <h2>Задание №6</h2>
        <p>Разработайте атрибутную директиву appHighlightInvalid для форм, которая задействует визуальную индикацию
          невалидности полей ввода и устанавливает фокус на первом невалидном элементе при попытке отправки формы. Эта
          директива позволит улучшить пользовательский опыт за счёт явного указания на ошибки ввода и ускорения процесса
          их исправления.</p>

        Требования:
        <ul>Функциональность:
          <li>Директива должна автоматически подсвечивать все невалидные поля формы, используя предварительно
            определённый класс CSS.
          </li>
          <li>При попытке отправки формы, директива должна устанавливать фокус на первом невалидном поле (если такое
            есть), облегчая тем самым корректировку данных пользователем.
          </li>
          <li>Директива будет применена к форме Angular, что позволит её использовать в различных частях вашего
            приложения для повышения общей удобности взаимодействия.
          </li>
          <li>Директива не должна вмешиваться, если в списке &lt;select> больше одного элемента &lt;option> доступно для
            выбора.
          </li>
        </ul>

        Результат выполнения: <br>
        <ul>
          <li>При применении директивы к форме и последующей попытке её отправки, все поля формы, которые не прошли
            валидацию, будут автоматически выделяться с помощью визуальной подсветки.
          </li>
          <li>В дополнение к этому, фокус автоматически переносится на первое невалидное поле в форме. Это означает, что
            пользователь сразу же может начать исправление ошибки, не тратя время на поиски поля, нуждающегося в
            коррекции. Такой подход позволяет значительно упростить и ускорить процесс заполнения формы, особенно когда
            форма содержит множество полей для ввода информации.
          </li>
        </ul>
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop6></app-dop6>
      </div>
    </div>
    <div class="dop7 dop">
      <div class="exercise">
        <h2>Задание №7</h2>
        <p>Создать атрибутную директиву appInputConstraint для элементов ввода `&lt;input>`, которая будет ограничивать
          ввод пользователя на основе заданного паттерна (регулярное выражение). Пользователь не должен иметь
          возможность ввести данные, которые не соответствуют заданным правилам (например, только цифры, только буквы,
          без специальных символов, определенный формат и т.д.).</p>
        <p>Разработайте атрибутную директиву appInputConstraint для элементов ввода &lt;input>, которая будет
          ограничивать
          ввод пользователя на основе заданного паттерна (регулярное выражение). Пользователь не должен иметь
          возможность ввести данные, которые не соответствуют заданным правилам (например, только цифры, только буквы,
          без специальных символов, определенный формат и т.д.).</p>

        Требования:
        <ul>Функциональность:
          <li>Директива должна принимать паттерн (регулярное выражение) через декоратор &#64;Input, который будет
            использоваться для валидации вводимых данных.
          </li>
          <li>Директива должна отслеживать события ввода (input) и предотвращать ввод символов, которые не соответствуют
            заданному паттерну.
          </li>
        </ul>

        Результат выполнения: <br>
        <ul>
          <li>При применении директивы к элементу &lt;input>, пользователь сможет вводить данные только в соответствии с
            заданным паттерном.
          </li>
          <li>Любые попытки ввода данных, не соответствующих паттерну, будут автоматически блокироваться.</li>
        </ul>
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop7></app-dop7>
      </div>
    </div>
    <div class="dop8 dop">
      <div class="exercise">
        <h2>Задание №8</h2>
        <p>Создайте атрибутную директиву LongPressReset, которая улучшает интерфейс формы за счет добавления
          функциональности "долгого нажатия" на кнопку "Сбросить". Чтобы предотвратить случайное срабатывание, кнопка
          должна оставаться нажатой на протяжении определенного времени (например, 3 секунды), перед тем как сбросить
          все данные формы. Эта функциональность особенно полезна в интерфейсах, где важно избежать нежелательного
          сброса данных из-за случайных кликов.</p>

        Требования:
        <ul>Функциональность:
          <li>Директива должна инициировать сброс данных формы только после того, как кнопка "Сбросить" удерживается
            нажатой на протяжении заданного времени (например, 3 секунды).
          </li>
          <li>Компонент или директива, использующие LongPressReset, должны иметь возможность настраивать
            продолжительность долгого нажатия с помощью параметра duration.
          </li>
          <li>После успешного долгого нажатия должно срабатывать событие или вызываться метод сброса данных формы.</li>
        </ul>

        Результат выполнения: <br>
        <ul>
          <li>Применяя директиву LongPressReset к кнопке сброса в форме и передавая параметр duration, разработчики
            могут легко добавить требуемую функциональность к своим формам. Это обеспечивает более осознанный и
            безопасный процесс сброса данных, защищая пользователей от случайных потерь введенной информации.
          </li>
          <li>Пример использования директивы: &lt;button longPressReset [duration]="3000"
            (onReset)="resetForm()">Сбросить&lt;/button>, где duration указывает время удержания кнопки в миллисекундах,
            а onReset - обработчик события, вызываемый после успешного срабатывания директивы.
          </li>
        </ul>
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop8></app-dop8>
        <h2>Реализация IT</h2>
        <app-dop8r></app-dop8r>
      </div>
    </div>
    <div class="dop9 dop">
      <div class="exercise">
        <h2>Задание №9</h2>
        <p>Создайте директиву FocusTrap, которая предназначена для управления переключением фокуса внутри модального
          окна. Основная задача этой директивы — обеспечить, чтобы в процессе навигации с помощью клавиши Tab, фокус не
          покидал пределы активного модального окна. Ключевая функциональность заключается в перехвате попыток
          перемещения фокуса за последний элемент управления внутри модального окна и последующем перенаправлении его на
          первый элемент управления. Это гарантирует, что пользователи, работающие с клавиатуры, не потеряют контекст
          взаимодействия при открытом модальном окне.</p>

        Требования:
        <ul>
          <li>Во время использования Tab для навигации, если пользователь достигает последнего элемента управления в
            модальном окне и пытается перейти дальше, фокус должен возвращаться к первому элементу управления в окне.
          </li>
          <li>Аналогично, при использовании Shift+Tab для навигации в обратном порядке, если пользователь находится на
            первом элементе управления и пытается перейти к предыдущему, фокус должен переходить к последнему элементу
            управления в окне.
          </li>
        </ul>

        Реализация
        <ol>
          <li>С помощью директивы FocusTrap прикрепите обработчики событий клавиатуры к модальному окну для контроля
            навигации фокуса.
          </li>
          <li>Используйте DOM операции для определения первого и последнего фокусируемых элементов в модальном окне.
          </li>
          <li>Реализуйте логику перехвата и перенаправления фокуса, чтобы обеспечить его циклическое перемещение в
            пределах модального окна.
          </li>
        </ol>

        <b>Пример применения:</b>
        <p>
          Добавьте атрибут focusTrap к корневому элементу модального окна для активации директивы, обеспечивающей
          удержание фокуса внутри окна, например:
          &lt;div focusTrap> ...&lt;/div>
          . Это обеспечит, что при взаимодействии с модальным окном, фокус будет оставаться в его пределах, поддерживая
          удобный и доступный интерфейс пользователя.
        </p>
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop9></app-dop9>
      </div>
    </div>
    <div class="dop10 dop">
      <div class="exercise">
        <h2>Задание №10</h2>
        <p>Разработайте атрибутную директиву appEllipsisTooltip, которая будет работать с текстовыми элементами в вашем
          веб-приложении. Если текст не умещается полностью в его родительский блок, директива должна обрезать его,
          добавлять многоточие и отображать тултип при наведении курсора. При этом, если текст полностью помещается в
          блок, многоточие и тултип отображаться не должны.</p>
        <p>Создайте атрибутную директиву appEllipsisTooltip, предназначенную для обработки текстовых элементов в вашем веб-приложении.
          Если текст не умещается полностью в его родительский блок, директива должна обрезать его, добавлять многоточие и отображать тултип при наведении курсора.
          При этом, если текст полностью помещается в блок, многоточие и тултип отображаться не должны.</p>

        Требования:
        <ul>
          <li>Директива должна проверять, умещается ли весь текст в родительском блоке. Если нет, то обрезать текст и добавить многоточие.</li>
          <li>При наведении курсора на обрезанный текст должен отображаться тултип с полным содержимым.</li>
          <li>Если весь текст помещается в блок без обрезки, многоточие и тултип не должны отображаться.</li>
        </ul>

        Реализация
        <ol>
          <li>Используйте ElementRef, чтобы получить доступ к DOM-элементу, содержащему текст.</li>
          <li>Оцените ширину текста и родительского блока, чтобы определить, требуется ли обрезка.</li>
          <li>При необходимости добавьте CSS-стили для обрезки текста и отображения многоточия.</li>
          <li>Добавьте обработчики событий для отображения тултипа при наведении курсора на обрезанный текст.</li>
        </ol>

        <b>Пример применения:</b>
        <p>Текст, который не умещается в блок, должен быть обрезан и должно быть многоточие. При наведении на этот текст, должен показаться тултип с полным текстом.</p>
      </div>
      <div>
        <h2>Реализация</h2>
        <app-dop10></app-dop10>
      </div>
    </div>
  </div>
</div>
